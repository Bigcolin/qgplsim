include("DGP.ji")
include("qgplsim.ji")
import Base.Threads.@threads
using Statistics, Clustering, DataFrames, CSV
using ProgressBars

function MonteCarlo(n, γ, θ, α, β, fx = 2, dist = 1, rep = 100)
    # fx = 1 # y = f(x), fx for different f(x)     
                # fx = 1, y = X*θ + Z*β + (X*α + Z*γ .- 1).^2 + 0.2ϵ
                # fx = 2, y = X*θ + Z*β + log.(1 .+ exp.(X*α + Z*γ .- 1)) + 0.2ϵ
    # dist = 1 # 1 for Cauchy, 0 for Gauss
    ifz = true # if false, Z = 0, i.e. no category varible
    τ = 0.5
    alpha_type = 1
    p = length(α)
    # t = time() 
    Theta0 = zeros(rep, p)
    Alpha0 = zeros(rep, p)
    Gamma0 = zeros(rep, 2)
    Beta0 = zeros(rep, 2)
    for j in tqdm(1:rep) 
        X, Z, y = dgp(n, γ, θ, α, β, fx, dist, ifz)
        model_ij = qgplsim.model(X, Z, y, τ)

        Alpha0[j, :], Theta0[j, :],
        Gamma0[j, :], Beta0[j, :] = qgplsim.estimator(model_ij, alpha_type)
    end

    Alpha0, Gamma0, Theta0, Beta0


end
function simulation(n::Int, fx = 2, dist = 0)
	α = [1.0, 2.0] # single index for x
	θ = [2.0, -1.0]  # linear for x, <α, θ> = 0 for identification
	# γ = [1.0, 0.5] # single index for z
	β = [1.0, -0.5] # linear for z
	# Q(y|x, z) = Xθ + Zβ + g(Xα + Zγ)
	# n = 400

	df = DataFrame(α1 = Float64[], α2 = Float64[],
		var_α1 = Float64[], var_α2 = Float64[],    
		θ1 = Float64[], θ2 = Float64[],
		var_θ1 = Float64[], var_θ2 = Float64[], 
		β1 = Float64[], β2 = Float64[],
		var_β1 = Float64[], var_β2 = Float64[], 
		γ1 = Float64[], γ2 = Float64[],
		var_γ1 = Float64[], var_γ2 = Float64[])

		for γ in [[0.0, 0.0], [1.0, 0.001], [1.0, 1.0], [1.0, 2.0], [1.0, 4.0], [0.001, 1.0], [2.0, 1.0], [4.0, 1.0]]
		
            Alpha, Theta, Gamma, Beta = MonteCarlo(n, γ, θ, α, β, fx, dist)
            Ra = kmeans(transpose(Alpha), 2)
            Rg = kmeans(transpose(Gamma), 2)
            ind1 = Ra.assignments .== 1
            ind2 = Ra.assignments .== 2
            Alpha1 = Alpha[ind1, :]
            Alpha2 = Alpha[ind2, :]
            Gamma1 = Gamma[ind1, :]
            Gamma2 = Gamma[ind2, :]
            n1 = sum(ind1)
            n2 = rep - n1
            alpha1 = abs.(sum(Alpha1, dims = 1))
            alpha2 = abs.(sum(Alpha2, dims = 1))
            gamma1 = abs.(sum(Gamma1, dims = 1))
            gamma2 = abs.(sum(Gamma2, dims = 1))
            alpha = (alpha1 + alpha2) / rep
            gamma = (gamma1 + gamma2) / rep
            theta = sum(Theta, dims = 1)/rep
            beta = sum(Beta, dims = 1)/rep
            vara = (var(Alpha1, dims = 1) * n1 + var(Alpha2, dims = 1) * n2)/rep
            varg = (var(Gamma1, dims = 1) * n1 + var(Gamma2, dims = 1) * n2)/rep
            vart = var(Theta, dims = 1)
            varb = var(Beta, dims = 1)
            res = Dict(:α1 => alpha[1], :α2 => alpha[2],
                    :θ1 => theta[1], :θ2 => theta[2],
                    :γ1 => gamma[1], :γ2 => gamma[2],
                    :β1 => beta[1], :β2 => beta[2],
                    :var_α1 => vara[1], :var_α2 => vara[2],
                    :var_θ1 => vart[1], :var_θ2 => vart[2],
                    :var_γ1 => varg[1], :var_γ2 => varg[2],
                    :var_β1 => varb[1], :var_β2 => varb[2])

			push!(df, res)
		end
		CSV.write("$n f$fx d$dist.csv", df)
end

function main(N = [250 300 500 600],
              F = [1 2], D = [0 1])

    set = []
     for n in N
        for f in F
            for d in D
                s = [n, f, d]
                push!(set, s)
            end
        end
    end
    
    @threads for s in set
        simulation(s[1],  s[2], s[3])       
    end

end