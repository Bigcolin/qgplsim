module localLinear_quantReg
using Distributions, LinearAlgebra, GLM, DataFrames
using Optim, QuantReg
include("supportFunctions.ji")

    function guruobi_solver(y, X, quantNum, dv)

		n = length(y)
		# df = DataFrame(X, :auto)
        df = DataFrame()
        try
            df = DataFrame(X, :auto)
        catch e
            if isa(e, MethodError)
                df = DataFrame(X)
            end
        end
        
        tau = quantNum[1]
		nox = Symbol.(names(df))
		df[!, :y] = y
		formula1 = Term(:y) ~ sum([Term(x) for x in nox])	
		model = QuantRegModel(formula1, df, τ = tau)

        try
            QuantReg.fit!(model)
        catch e
            ot = DataFrame([w yi Xi], :auto)
            println(ot[1:5, :])

        end
        res = coef(model)[(dv + 1):end]
        res[1] += coef(model)[1]
        res
    end

    function solver(yi::Vector, Xi::Matrix, w::Vector, tau, dv = 1, method="optim_qr")
        n = length(yi)
        if dv == 1 || method == "mean"
            X = [ones(n, 1) Xi] 
        else
            X = ones(n, 1) 
        end
        
        n, d = size(X)
        b0 = zeros(d)
        if method == "optim_qr"	   
            y = yi .* w 
            X = X .* w
            r(x) = ρ(x, tau)
            tarfunc(b::Vector) = sum(r.(y - X*b))
            res = Optim.optimize(tarfunc, zeros(d), method = BFGS(), f_tol = 5e-6)
            b0 = Optim.minimizer(res)
        
        elseif method == "gurobi"
            y = yi .* w 
            X = X .* w
            b0 = guruobi_solver(y, X, tau, dv)
        
        elseif method == "mean"
#             W = Diagonal(w)
#             b0 = pinv(transpose(X) * W * X)*transpose(X) * W * yi
            b0 = pinv(transpose(X .* w) * X)*transpose(X .* w) * yi
        
        elseif  method == "mmqr"
            t0 = pinv(transpose(X .* w) * X)*transpose(X .* w) * yi
            b0 = mmqr(yi, X, tau, t0)
        end
        return b0
    end

    function mmqr(yi, Xi, tau, theta0, eps = 0.47, tol = 1e-6)
        q = tau[1]
        thetak = theta0 .+ 100*tol
        max_iter = 100
        k = 0
        while norm(thetak - theta0) > tol && k < max_iter

            theta0 = thetak
            rk = yi - Xi * theta0
            W = Diagonal(1 ./ (eps .+ rk))
            v = 1 .- 2q .- rk ./ (eps .+ rk)
            Δ = -pinv(transpose(Xi) * W * Xi)*transpose(Xi) * v
            thetak = theta0 + Δ
            # println(thetak)
            k += 1
        end

        thetak
    
    end

end