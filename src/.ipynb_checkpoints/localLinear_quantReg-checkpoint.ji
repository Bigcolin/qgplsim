module localLinear_quantReg
using Distributions, LinearAlgebra, QuantReg, GLM, DataFrames
using Optim
include("supportFunctions.ji")

#     function direct_optim(yi, Xi, w, tau = 0.5)
# 		y = yi .* w    
# 		n = length(y)
#         it = 1
# 		X = [ones(n, it) Xi] .* w
# 		# df = DataFrame(X, :auto)
#         df = DataFrame()
#         try
#             df = DataFrame(X, :auto)
#         catch e
#             if isa(e, MethodError)
#                 df = DataFrame(X)
#             end
#         end
# 		nox = Symbol.(names(df))
# 		df[!, :y] = y
# 		formula1 = Term(:y) ~ sum([Term(x) for x in nox])	
# 		model = QuantRegModel(formula1, df, τ = tau)

#         try
#             QuantReg.fitgurobi!(model)
#         catch e
#             ot = DataFrame([w yi Xi], :auto)
#             println(ot[1:5, :])

#         end
#         res = coef(model)[(it + 1):end]
#         res[1] += coef(model)[1]
#         res
#     end

    function solver(yi::Vector, Xi::Matrix, w::Vector, tau, dv = 1, method="optim")
        n = length(yi)
        if dv == 1 || method == "mean"
            X = [ones(n, 1) Xi] 
        else
            X = ones(n, 1) 
        end
        n, d = size(X)
        b0 = zeros(d)
        if method == "optim"	   
            y = yi .* w 
            X = X .* w
            r(x) = ρ(x, tau)
            tarfunc(b::Vector) = sum(r.(y - X*b))
            res = Optim.optimize(tarfunc, zeros(d), method = BFGS(), f_tol = 1e-6)
            b0 = Optim.minimizer(res)
        
        elseif method == "mean"
            y = yi  
            X = X
            W = Diagonal(w)
            b0 = pinv(transpose(X) * W * X)*transpose(X) * W * y
        
        elseif  method == "mm"
            y = yi .* w 
            X = X .* w
            t0 = pinv(transpose(X) * X)*transpose(X)* y
            b0 = mmqr(y, X, tau, t0)
        end
        return b0
    end

    function mmqr(yi, Xi, tau, theta0, eps = 0.07, tol = 1e-6)
        q = tau[1]
        thetak = theta0 .+ 1000*tol
        max_iter = 1000
        k = 0
        while norm(thetak - theta0) > tol && k < max_iter

            theta0 = thetak
            rk = yi - Xi * theta0
            W = Diagonal(1 ./ (eps .+ rk))
            v = 1 .- 2q .- rk ./ (eps .+ rk)
            Δ = -pinv(transpose(Xi) * W * Xi)*transpose(Xi) * v
            thetak = theta0 + Δ
            # println(thetak)
            k += 1
        end

        thetak
    
    end

end