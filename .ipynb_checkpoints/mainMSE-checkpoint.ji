include("supportFunctions.ji")
include("MonteCarloMSE.ji")
import Base.Threads.@threads

α = [1.0, 2.0] # single index for x
len_α = sqrt(5)
θ = [2.0, -1.0]  # linear for x, <α, θ> = 0 for identification
γ = [1.0, 0.5] # single index for z
β = [1.0, -0.5] # linear for z
# Q(y|x, z) = Xθ + Zβ + g(Xα + Zγ)

n = 300
fx = 1 # y = f(x), fx for different f(x)     
                # fx = 1, y = X*θ + Z*β + (X*α + Z*γ .- 1).^2 + 0.2ϵ
                # fx = 2, y = X*θ + Z*β + log.(1 .+ exp.(X*α + Z*γ .- 1)) + 0.2ϵ
ifz = true # if false, Z = 0, i.e. no category varible
dist = 0 # Cauchy or Gauss
alpha_type = 1
rep = 100
# Alpha, Theta, Gamma, Beta =  MonteCarlo(n, γ, θ, α, β, fx, dist, rep, alpha_type)

            Γ = repeat(transpose(γ), rep, 1)
	    Β = repeat(transpose(β), rep, 1)
            Θ = repeat(transpose(θ), rep, 1)

            cosm2 = m2(Alpha, α)
            sign_α = sign.(cosm2)
            sinm2 = 1 .- cosm2.^2

            mean_α, var_α = mean(sinm2), var(sinm2)
            Δγ = abs.(Gamma .* sign_α - Γ).^2
            mean_γ, var_γ = mean(Δγ, dims = 1), var(Δγ, dims = 1)
            Δβ = Beta - Β  # abs.(Beta - Β).^2
            mean_β, var_β = mean(Δβ, dims = 1), var(Δβ, dims = 1)
            Δθ = Theta - Θ  # abs.(Theta - Θ).^2
            mean_θ, var_θ = mean(Δθ, dims = 1), var(Δθ, dims = 1)

            res = Dict(:α => mean_α, :var_α => var_α,
                      :θ1 => mean_θ[1], :θ2 => mean_θ[2],
                      :γ1 => mean_γ[1], :γ2 => mean_γ[2],
                      :β1 => mean_β[1], :β2 => mean_β[2],
                      :var_θ1 => var_θ[1], :var_θ2 => var_θ[2],
                      :var_γ1 => var_γ[1], :var_γ2 => var_γ[2],
                      :var_β1 => var_β[1], :var_β2 => var_β[2])
        
res