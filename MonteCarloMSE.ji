include("DGP.ji")
include("qgplsim.ji")
include("supportFunctions.ji")
import Base.Threads.@threads
using Statistics, Clustering, DataFrames, CSV, MAT
using ProgressBars

function MonteCarlo(n, γ, θ, α, β, fx = 2, dist = 1, len = 100, alpha_type = 1)
    # fx = 1 # y = f(x), fx for different f(x)     
                # fx = 1, y = X*θ + Z*β + (X*α + Z*γ .- 1).^2 + 0.2ϵ
                # fx = 2, y = X*θ + Z*β + log.(1 .+ exp.(X*α + Z*γ .- 1)) + 0.2ϵ
    # dist = 1 # 1 for Cauchy, 0 for Gauss
    ifz = true # if false, Z = 0, i.e. no category varible
    τ = 0.5
    p = length(α)
    # t = time() 
    Theta0 = zeros(len, p)
    Alpha0 = zeros(len, p)
    Gamma0 = zeros(len, 2)
    Beta0 = zeros(len, 2)
    for j in tqdm(1:len) # each 25
        X, Z, y = dgp(n, γ, θ, α, β, fx, dist, ifz)
        model_ij = qgplsim.model(X, Z, y, τ)

        Alpha0[j, :], Theta0[j, :],
        Gamma0[j, :], Beta0[j, :] = qgplsim.estimator(model_ij, alpha_type)
    end
    # println("MC Computing time: ", time() - t)

    # Alpha, Theta, Gamma, Beta = Alpha1, Theta1, Gamma1, Beta1
    Alpha, Theta, Gamma, Beta = Alpha0, Theta0, Gamma0, Beta0
    Alpha, Theta, Gamma, Beta

end
function simulation(n::Int, fx = 2, dist = 0, rep = 100)
	α = [1.0, 2.0] # single index for x
    len_α = sqrt(5)
	θ = [2.0, -1.0]  # linear for x, <α, θ> = 0 for identification
	# γ = [1.0, 0.5] # single index for z
	β = [1.0, -0.5] # linear for z
	# Q(y|x, z) = Xθ + Zβ + g(Xα + Zγ)
	# n = 400

	df = DataFrame(gm1 = Float64[], gm2 = Float64[],
                   α = Float64[], var_α = Float64[],    
		           θ1 = Float64[], θ2 = Float64[],
		           var_θ1 = Float64[], var_θ2 = Float64[], 
		           β1 = Float64[], β2 = Float64[],
		           var_β1 = Float64[], var_β2 = Float64[], 
		           γ1 = Float64[], γ2 = Float64[],
		           var_γ1 = Float64[], var_γ2 = Float64[])
		for γ in [[0.001, 0.001], [1.0, 0.001], [1.0, 1.0], [1.0, 0.5], [0.001, 1.0], [0.5, 1.0]]
            g1, g2 = γ[1], γ[2]
            Alpha, Theta, Gamma, Beta =  MonteCarlo(n, γ, θ, α, β, fx, dist, rep)
            matwrite("./simulation_mse/records/$n f$fx d$dist $g1 $g2.mat", 
                     Dict("Alpha" => Alpha, "Theta" => Theta, "Gamma" => Gamma, "Beta" => Beta))

                        
            Γ = repeat(transpose(γ), rep, 1)
	        Β = repeat(transpose(β), rep, 1)
            Θ = repeat(transpose(θ), rep, 1)

            cosm2 = m2(Alpha, α)
            sign_α = sign.(cosm2)
            sinm2 = 1 .- cosm2.^2

            mean_α, var_α = mean(sinm2), var(sinm2)
            Δγ = abs.(Gamma .* sign_α - Γ).^2
            mean_γ, var_γ = mean(Δγ, dims = 1), var(Δγ, dims = 1)
            Δβ = abs.(Beta - Β).^2
            mean_β, var_β = mean(Δβ, dims = 1), var(Δβ, dims = 1)
            Δθ = abs.(Theta - Θ).^2
            mean_θ, var_θ = mean(Δθ, dims = 1), var(Δθ, dims = 1)

            res = Dict(:gm1 => g1, :gm2 => g2,
                       :α => mean_α, :var_α => var_α,
                       :θ1 => mean_θ[1], :θ2 => mean_θ[2],
                       :γ1 => mean_γ[1], :γ2 => mean_γ[2],
                       :β1 => mean_β[1], :β2 => mean_β[2],
                       :var_θ1 => var_θ[1], :var_θ2 => var_θ[2],
                       :var_γ1 => var_γ[1], :var_γ2 => var_γ[2],
                       :var_β1 => var_β[1], :var_β2 => var_β[2])
			push!(df, res)
		end
		CSV.write("./simulation_mse/$n f$fx d$dist.csv", df)
end

function main(N = [300 600],
              F = [1 2], D = [0 1])

    set = []
     for n in N
        for f in F
            for d in D
                s = [n, f, d]
                push!(set, s)
            end
        end
    end
    
    for s in set
        simulation(s[1], s[2], s[3])       
    end

end